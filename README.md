# Network_Programming
一些常见的网络编程问题

## 5种I/O模式
1. 阻塞I/O(Linux下的I/O操作默认使阻塞I/O，即open和socket创建的I/O都是阻塞I/O)
阻塞I/O：当没有数据到达时，系统进程处于阻塞状态，进程让出CPU，进入休息队列，等有数据到达时，内核会唤醒数据读取数据(数据拷贝)

recvfrom ---系统调用---> 没有数据就绪 ---等待数据---> 数据就绪，进行拷贝 ---将数据从内核中拷贝出来---> 拷贝结束 ---正常结束，返回用户态---> 处理数据

![图片](<README_Photoes/1.png>)

example：linux下默认使用阻塞I/O

2. 非阻塞I/O(可以通过fcnl或者open时使用O_NONBLOCK参数，将fd设置为非阻塞的I/O)
非阻塞模式I/O使用并不普遍，因为非阻塞方式会浪费大量的CPU资源，当请求的IO操作不能立马完成的时候，进程会立马返回一个EWOULDBLOCK错误，当数据报到达后，应用程序再次请求系统调用，内核将到达的数据报(socket接收到的数据报首先是存储在系统态的缓冲区)拷贝到应用程序的缓冲区中，然后应用程序就可以对数据进行处理。
由于应用程序是非阻塞的方式，他需要使用一各循环来不断测试是否一个文件描述符有数据可读(称作polling(轮询))。应用程序不断的polling内核来检查I/O操作是否已经就绪，这非常浪费CPU资源，但是实时性比较好

recvfrom ---系统调用---> 没有数据，返回EWOULDBLOCK错误 ---内核等待数据---> 应用程序非阻塞，采取轮询的方式不断测试，浪费大量的CPU资源 ------> 数据到达内核 ------> 数据拷贝到应用程序缓冲区(数据拷贝)

![图片](<README_Photoes/2.png>)

example: 对于管道的操作，最好使用非阻塞的方式。

3. I/O多路复用(通常需要非阻塞I/O配合使用)
在使用I/O对路复用技术的时候，我们调用select函数和poll函数或者epoll函数(2.6内核开始支持)。对于单个I/O操作，多路复用技术和阻塞模式并没有什么区别，select和poll或epoll并没有什么高级的地方。在阻塞模式下我们只需要调用一个函数:读取或者发送函数，在使用多路复用技术后，我们需要调用两个函数，先调用select函数或poll函数，然后才能进行真正的读写操作。
I/O多路复用技术真正的优点在于：他能同时等待多个文件描述符，而这些文件描述符(套接字描述符)其中的任意一个进入读就绪状态，select函数就可以返回。

![图片](<README_Photoes/3.png>)

使用场景:
1. 一个和SIGIO信号的处理函数必须设定。
2. 套接字的拥有者必须被设定。一般来说使用fcntl函数的F_SETOWN参数来进行设定拥有者。
3. 套接字被允许使用异步I/O。一般通过fcntl函数的F_SETFL命令，O_ASYNC为参数来实现。虽然设定套接字为异步I/O比较简单，但是使用起来困难的部分在于怎么在程序中断产生SIGIO信号发送给属主套接字的时候，程序处在什么位子。 
一个对信号驱动I/O比较实用的方面使NTP(网络时间协议)服务器，它使用的UDP


4. 信号驱动I/O
使用信号，让内核在文件描述符就绪的时候使用SIGIO信号来通知我们，我们将这种模式成为信号驱动I/O模式。
首先使通过系统调用建立SIGIO处理函数，当数据就绪时内核发送SIGNO信号，应用程序接收信号，接收数据recvfrom进行系统调用将网络通讯的数据从内核当中拷贝到应用程序的缓冲区，拷贝完成后应用程序处理数据。

![图片](<README_Photoes/4.png>)

必须条件：
1. 一个和SIGIO信号的处理函数必须设定。
2. 套接字的拥有者必须被设定，

5. 异步I/O
当我们运行在异步I/O的模式下，如果我们想进行I/O操作，只需要告诉内核我们要进行I/O操作，然后内核马上就会返回，具体的I/O和数据拷贝操作全部由北河来完成，我们程序可以继续向下执行，当内核完成所有的I/O操作和数据拷贝后，内核会通知我们的程序。
异步I/O和信号驱动I/O的区别:
1. 信号驱动I/O模式下，内核可以在被操作的时候给我们的应用程序发送SIGIO消息。
2. 异步I/O模式下，内核在所有的操作都已经被内核操作结束后才会通知我们的应用程序。

![图片](<README_Photoes/5.png>)

### Epoll模型详解
Linux 2.6内核中提高网络I/O性能新的方法epoll I/O多路复用技术在比较多的TCP网络服务器中使用，select函数用的较多。
1. 传统的select模型的缺点
select所用到的FD_SET是有限的，即内核中有个参数_FD_SETSIZE定义了每个FD_SET的句柄个数，在2.6版本中该值使1024，也就是说如果想要同时检测1025个句柄的可读状态是不可能用select实现的，再者select是使用的轮询的方法，轮询的时间也和句柄的个数呈现线性相关。(poll也相似)
2. linux 2.6版本提高I/O性能的新方法epoll
epoll是为了处理大量句柄而改进了poll，要使用epoll只需要这三个系统调用：epoll_create(2) epoll_ctl(2) epoll_wait(2)。尽管上面的I/O模型中AIO模型是最为高效的，但是知道2.6内核版本的发布，网络模块AIO一直没有进入稳定的内核版本。

epoll的优点:
1. 支持一个进程打开大数目的socket描述符(FD)
select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是1024。对于那些需要支持的上万连接数目的IM服务器来说显 然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完 美的方案。不过 epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于1024,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。

2. IO效率不随着FD数目增加而线性下降
传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是”活跃”的， 但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行 操作—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个”伪”AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的—比如一个高速LAN环境，epoll并不比select/poll有什么效率，相 反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。

3. 使用mmap(内存映射)加速内核与用户空间的消息传递。
这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就 很重要。在这一点上epoll通过内核与用户空间mmap同一块内存实现的。(linux 2.5 手工映射mmap)

4. 内核微调
这一点其实不算epoll的优点了，而是整个linux平台的优点。也许你可以怀疑 linux平台，但是你无法回避linux平台赋予你微调内核的能力。比如，内核TCP/IP协议栈使用内存池管理sk_buff结构，那么可以在运行时期动态调整这个内存pool(skb_head_pool)的大小— 通过echo XXXX>/proc/sys/net/core/hot_list_length完成。再比如listen函数的第2个参数(TCP完成3次握手的数据包队列长度也可以根据你平台内存大小动态调整。更甚至在一个数据包数目巨大但同时每个数据包本身大小却很小的特殊系统上尝试最新的NAPI网卡驱动架构。

epoll的工作模式
epoll有两种工作模式LT和ET：
令人高兴的是，2.6内核的epoll比其2.5开发版本的/dev/epoll简洁了许多，所以，大部分情况下，强大的东西往往是简单的。唯一有点麻烦 是epoll有2种工作方式:LT和ET。

1. LT(level triggered)缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd进行IO操作。如果你不作任何操作，内核还是会继续通知你，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。
2. ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once),不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。epoll只有epoll_create,epoll_ctl,epoll_wait 3个系统调用，具体用法请参考http://www.xmailserver.org/linux-patches/nio-improve.html，在http://www.kegel.com/rn/也有一个完整的例子，大家一看就知道如何使用了
Leader/follower模式线程pool实现，以及和epoll的配合。

epoll 的使用方法
https://blog.csdn.net/chenchong_219/article/details/35822803






